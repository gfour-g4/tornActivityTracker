================================================================================
EXPORTED FILES FOR AI CHATBOT
Export Date: 12/30/2025, 9:53:23 PM
Total Files: 10
================================================================================

File: package.json
----------------------------------------
{
    "name": "torn-activity-bot",
    "version": "1.0.0",
    "description": "Discord bot to track Torn faction member activity",
    "main": "src/index.js",
    "scripts": {
      "start": "node src/index.js",
      "dev": "node --watch src/index.js"
    },
    "dependencies": {
      "canvas": "^2.11.2",
      "discord.js": "^14.14.1",
      "dotenv": "^16.3.1"
    },
    "engines": {
      "node": ">=18.0.0"
    }
  }

================================================================================

File: src/collector.js
----------------------------------------
const api = require('./utils/api');
const storage = require('./utils/storage');

let collectorInterval = null;

async function collectFactionData(factionId) {
    try {
        const pollTimestamp = Math.floor(Date.now() / 1000);
        const factionData = await api.fetchFaction(factionId);
        const { active, total } = api.processActivitySnapshot(factionData, pollTimestamp);
        
        storage.addSnapshot(factionId, factionData.name, pollTimestamp, active, total);
        
        console.log(`[${new Date().toISOString()}] Collected data for ${factionData.name}: ${active.length}/${total} active`);
        
        return true;
    } catch (error) {
        console.error(`[${new Date().toISOString()}] Error collecting faction ${factionId}:`, error.message);
        return false;
    }
}

async function collectAllFactions() {
    const config = storage.loadConfig();
    
    if (config.factions.length === 0) {
        console.log('[Collector] No factions configured to track.');
        return;
    }
    
    if (config.apikeys.length === 0) {
        console.log('[Collector] No API keys configured.');
        return;
    }
    
    console.log(`[${new Date().toISOString()}] Starting collection for ${config.factions.length} factions...`);
    
    for (const factionId of config.factions) {
        await collectFactionData(factionId);
        
        // Small delay between requests to be nice to the API
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

function startCollector() {
    if (collectorInterval) {
        console.log('[Collector] Already running.');
        return;
    }
    
    console.log('[Collector] Starting... Will collect every 15 minutes.');
    
    // Collect immediately on start
    collectAllFactions();
    
    // Then every 15 minutes
    collectorInterval = setInterval(collectAllFactions, 15 * 60 * 1000);
}

function stopCollector() {
    if (collectorInterval) {
        clearInterval(collectorInterval);
        collectorInterval = null;
        console.log('[Collector] Stopped.');
    }
}

module.exports = {
    startCollector,
    stopCollector,
    collectAllFactions,
    collectFactionData
};

================================================================================

File: src/commands/activity.js
----------------------------------------
const { SlashCommandBuilder, AttachmentBuilder } = require('discord.js');
const heatmap = require('../heatmap');

const GRANULARITY_CHOICES = [
    { name: 'Hourly', value: 'hourly' },
    { name: '15 Minutes', value: '15min' }
];

const DAYS_CHOICES = [
    { name: 'All Days', value: 'all' },
    { name: 'Weekdays (Mon-Fri)', value: 'weekday' },
    { name: 'Weekend (Sat-Sun)', value: 'weekend' }
];

module.exports = {
    data: new SlashCommandBuilder()
        .setName('activity')
        .setDescription('View activity heatmaps')
        .addSubcommand(subcommand =>
            subcommand
                .setName('faction')
                .setDescription('View faction activity heatmap')
                .addIntegerOption(option =>
                    option
                        .setName('id')
                        .setDescription('Faction ID')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option
                        .setName('granularity')
                        .setDescription('Time granularity')
                        .addChoices(...GRANULARITY_CHOICES)
                )
                .addStringOption(option =>
                    option
                        .setName('days')
                        .setDescription('Days to include (all, weekday, weekend, or comma-separated: mon,tue,wed)')
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('user')
                .setDescription('View user activity heatmap')
                .addIntegerOption(option =>
                    option
                        .setName('id')
                        .setDescription('User ID')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option
                        .setName('granularity')
                        .setDescription('Time granularity')
                        .addChoices(...GRANULARITY_CHOICES)
                )
                .addStringOption(option =>
                    option
                        .setName('days')
                        .setDescription('Days to include (all, weekday, weekend, or comma-separated)')
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('compare')
                .setDescription('Compare two factions')
                .addIntegerOption(option =>
                    option
                        .setName('faction1')
                        .setDescription('First faction ID')
                        .setRequired(true)
                )
                .addIntegerOption(option =>
                    option
                        .setName('faction2')
                        .setDescription('Second faction ID')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option
                        .setName('granularity')
                        .setDescription('Time granularity')
                        .addChoices(...GRANULARITY_CHOICES)
                )
                .addStringOption(option =>
                    option
                        .setName('days')
                        .setDescription('Days to include (all, weekday, weekend, or comma-separated)')
                )
        ),

    async execute(interaction) {
        const subcommand = interaction.options.getSubcommand();
        const granularity = interaction.options.getString('granularity') || 'hourly';
        const days = interaction.options.getString('days') || 'all';

        await interaction.deferReply();

        try {
            if (subcommand === 'faction') {
                const factionId = interaction.options.getInteger('id');
                const imageBuffer = await heatmap.createFactionHeatmap(factionId, granularity, days);
                
                const attachment = new AttachmentBuilder(imageBuffer, { 
                    name: `faction_${factionId}_activity.png` 
                });
                
                await interaction.editReply({ files: [attachment] });
                
            } else if (subcommand === 'user') {
                const userId = interaction.options.getInteger('id');
                const imageBuffer = await heatmap.createUserHeatmap(userId, granularity, days);
                
                const attachment = new AttachmentBuilder(imageBuffer, { 
                    name: `user_${userId}_activity.png` 
                });
                
                await interaction.editReply({ files: [attachment] });
                
            } else if (subcommand === 'compare') {
                const faction1Id = interaction.options.getInteger('faction1');
                const faction2Id = interaction.options.getInteger('faction2');
                
                const { sideBySide, difference } = await heatmap.createComparisonHeatmaps(
                    faction1Id, faction2Id, granularity, days
                );
                
                const attachment1 = new AttachmentBuilder(sideBySide, { 
                    name: 'comparison_side_by_side.png' 
                });
                const attachment2 = new AttachmentBuilder(difference, { 
                    name: 'comparison_difference.png' 
                });
                
                await interaction.editReply({ 
                    content: '**Side-by-side comparison:**',
                    files: [attachment1] 
                });
                
                await interaction.followUp({ 
                    content: '**Difference heatmap:**',
                    files: [attachment2] 
                });
            }
        } catch (error) {
            console.error('Activity command error:', error);
            await interaction.editReply({ 
                content: `âŒ Error: ${error.message}` 
            });
        }
    }
};

================================================================================

File: src/commands/config.js
----------------------------------------
const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');
const storage = require('../utils/storage');
const collector = require('../collector');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('config')
        .setDescription('Configure the activity tracker')
        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
        .addSubcommand(subcommand =>
            subcommand
                .setName('add')
                .setDescription('Add factions or API keys')
                .addStringOption(option =>
                    option
                        .setName('factions')
                        .setDescription('Comma-separated faction IDs')
                )
                .addStringOption(option =>
                    option
                        .setName('apikeys')
                        .setDescription('Comma-separated API keys')
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('remove')
                .setDescription('Remove a faction or API key')
                .addIntegerOption(option =>
                    option
                        .setName('faction')
                        .setDescription('Faction ID to remove')
                )
                .addStringOption(option =>
                    option
                        .setName('apikey')
                        .setDescription('API key to remove')
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('list')
                .setDescription('Show current configuration')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('collect')
                .setDescription('Manually trigger data collection')
        ),

    async execute(interaction) {
        const subcommand = interaction.options.getSubcommand();

        if (subcommand === 'add') {
            const factionsInput = interaction.options.getString('factions');
            const apikeysInput = interaction.options.getString('apikeys');
            
            if (!factionsInput && !apikeysInput) {
                return interaction.reply({ 
                    content: 'âŒ Please provide factions or apikeys to add.', 
                    ephemeral: true 
                });
            }
            
            const config = storage.loadConfig();
            const added = [];
            
            if (factionsInput) {
                const factionIds = factionsInput.split(',')
                    .map(id => parseInt(id.trim()))
                    .filter(id => !isNaN(id) && !config.factions.includes(id));
                
                config.factions.push(...factionIds);
                if (factionIds.length > 0) {
                    added.push(`${factionIds.length} faction(s)`);
                }
            }
            
            if (apikeysInput) {
                const keys = apikeysInput.split(',')
                    .map(k => k.trim())
                    .filter(k => k.length > 0 && !config.apikeys.includes(k));
                
                config.apikeys.push(...keys);
                if (keys.length > 0) {
                    added.push(`${keys.length} API key(s)`);
                }
            }
            
            storage.saveConfig(config);
            
            if (added.length > 0) {
                await interaction.reply({ 
                    content: `âœ… Added ${added.join(' and ')}.`, 
                    ephemeral: true 
                });
            } else {
                await interaction.reply({ 
                    content: 'âš ï¸ Nothing new to add (items may already exist).', 
                    ephemeral: true 
                });
            }
            
        } else if (subcommand === 'remove') {
            const factionId = interaction.options.getInteger('faction');
            const apikey = interaction.options.getString('apikey');
            
            if (!factionId && !apikey) {
                return interaction.reply({ 
                    content: 'âŒ Please provide a faction or apikey to remove.', 
                    ephemeral: true 
                });
            }
            
            const config = storage.loadConfig();
            const removed = [];
            
            if (factionId) {
                const index = config.factions.indexOf(factionId);
                if (index > -1) {
                    config.factions.splice(index, 1);
                    removed.push(`faction ${factionId}`);
                }
            }
            
            if (apikey) {
                const index = config.apikeys.indexOf(apikey);
                if (index > -1) {
                    config.apikeys.splice(index, 1);
                    // Adjust currentKeyIndex if needed
                    if (config.currentKeyIndex >= config.apikeys.length) {
                        config.currentKeyIndex = 0;
                    }
                    removed.push('API key');
                }
            }
            
            storage.saveConfig(config);
            
            if (removed.length > 0) {
                await interaction.reply({ 
                    content: `âœ… Removed ${removed.join(' and ')}.`, 
                    ephemeral: true 
                });
            } else {
                await interaction.reply({ 
                    content: 'âš ï¸ Item not found.', 
                    ephemeral: true 
                });
            }
            
        } else if (subcommand === 'list') {
            const config = storage.loadConfig();
            const allFactionData = storage.getAllFactionData();
            
            let response = '**ðŸ“Š Activity Tracker Configuration**\n\n';
            
            response += `**Factions (${config.factions.length}):**\n`;
            if (config.factions.length === 0) {
                response += '> None configured\n';
            } else {
                for (const factionId of config.factions) {
                    const data = allFactionData[factionId];
                    const name = data?.name || 'Unknown';
                    const snapshots = data?.snapshots?.length || 0;
                    response += `> â€¢ ${name} [${factionId}] - ${snapshots} snapshots\n`;
                }
            }
            
            response += `\n**API Keys:** ${config.apikeys.length} configured\n`;
            
            await interaction.reply({ content: response, ephemeral: true });
            
        } else if (subcommand === 'collect') {
            await interaction.deferReply({ ephemeral: true });
            
            await collector.collectAllFactions();
            
            await interaction.editReply({ 
                content: 'âœ… Data collection completed. Check console for details.' 
            });
        }
    }
};

================================================================================

File: src/heatmap.js
----------------------------------------
const { createCanvas } = require('canvas');
const { 
    parseDaysFilter, 
    getHourFromTimestamp,
    get15MinSlotInHour,
    getDayOfWeek, 
    formatTimeSlot, 
    getThirtyDaysAgo,
    getWeekId,
    getUniqueWeeks,
    DAY_LABELS
} = require('./utils/helpers');
const storage = require('./utils/storage');

// Color interpolation: Red -> Yellow -> Green
function getColor(value, min, max) {
    if (max === min) {
        return 'rgb(255, 255, 0)';
    }
    
    const ratio = Math.max(0, Math.min(1, (value - min) / (max - min)));
    
    let r, g, b;
    
    if (ratio < 0.5) {
        const t = ratio * 2;
        r = 255;
        g = Math.round(255 * t);
        b = 50;
    } else {
        const t = (ratio - 0.5) * 2;
        r = Math.round(255 * (1 - t));
        g = 255;
        b = 50;
    }
    
    return `rgb(${r}, ${g}, ${b})`;
}

function getTextColor(value, min, max) {
    const ratio = max > min ? (value - min) / (max - min) : 0.5;
    return ratio > 0.3 ? '#000000' : '#FFFFFF';
}

// ============================================
// FACTION AGGREGATION
// ============================================

/**
 * Aggregate faction data - hourly view
 * For each (day, hour): find unique active members per week, then average across weeks
 */
function aggregateFactionDataHourly(factionData, dayFilter) {
    const daysToShow = parseDaysFilter(dayFilter);
    const thirtyDaysAgo = getThirtyDaysAgo();
    const now = Math.floor(Date.now() / 1000);
    
    // Structure: [hour][day][weekId] = Set of member IDs
    const hourlyData = {};
    for (let hour = 0; hour < 24; hour++) {
        hourlyData[hour] = {};
        for (const day of daysToShow) {
            hourlyData[hour][day] = {};
        }
    }
    
    // Process snapshots
    for (const snapshot of factionData.snapshots) {
        if (snapshot.timestamp < thirtyDaysAgo) continue;
        
        const day = getDayOfWeek(snapshot.timestamp);
        if (!daysToShow.includes(day)) continue;
        
        const hour = getHourFromTimestamp(snapshot.timestamp);
        const weekId = getWeekId(snapshot.timestamp, now);
        
        if (!hourlyData[hour][day][weekId]) {
            hourlyData[hour][day][weekId] = new Set();
        }
        
        // Add all active members to this hour's set for this week
        for (const memberId of snapshot.active) {
            hourlyData[hour][day][weekId].add(memberId);
        }
    }
    
    // Calculate averages
    const result = {};
    let globalMin = Infinity;
    let globalMax = -Infinity;
    
    for (let hour = 0; hour < 24; hour++) {
        result[hour] = {};
        for (const day of daysToShow) {
            const weekData = hourlyData[hour][day];
            const weekIds = Object.keys(weekData);
            
            if (weekIds.length === 0) {
                result[hour][day] = 0;
            } else {
                // Sum unique members per week, then average
                let total = 0;
                for (const weekId of weekIds) {
                    total += weekData[weekId].size;
                }
                result[hour][day] = Math.round(total / weekIds.length * 10) / 10;
            }
            
            if (result[hour][day] < globalMin) globalMin = result[hour][day];
            if (result[hour][day] > globalMax) globalMax = result[hour][day];
        }
    }
    
    return { 
        data: result, 
        min: globalMin === Infinity ? 0 : globalMin, 
        max: globalMax === -Infinity ? 0 : globalMax, 
        days: daysToShow 
    };
}

/**
 * Aggregate faction data - 15min view (compact format)
 * Returns hourly rows, but each cell has 4 values for the 15-min slots
 */
function aggregateFactionData15Min(factionData, dayFilter) {
    const daysToShow = parseDaysFilter(dayFilter);
    const thirtyDaysAgo = getThirtyDaysAgo();
    const now = Math.floor(Date.now() / 1000);
    
    // Structure: [hour][day][slot][weekId] = Set of member IDs
    const data = {};
    for (let hour = 0; hour < 24; hour++) {
        data[hour] = {};
        for (const day of daysToShow) {
            data[hour][day] = {
                0: {}, // :00
                1: {}, // :15
                2: {}, // :30
                3: {}  // :45
            };
        }
    }
    
    // Process snapshots
    for (const snapshot of factionData.snapshots) {
        if (snapshot.timestamp < thirtyDaysAgo) continue;
        
        const day = getDayOfWeek(snapshot.timestamp);
        if (!daysToShow.includes(day)) continue;
        
        const hour = getHourFromTimestamp(snapshot.timestamp);
        const slot = get15MinSlotInHour(snapshot.timestamp);
        const weekId = getWeekId(snapshot.timestamp, now);
        
        if (!data[hour][day][slot][weekId]) {
            data[hour][day][slot][weekId] = new Set();
        }
        
        for (const memberId of snapshot.active) {
            data[hour][day][slot][weekId].add(memberId);
        }
    }
    
    // Calculate averages - each cell now has 4 values
    const result = {};
    let globalMin = Infinity;
    let globalMax = -Infinity;
    
    for (let hour = 0; hour < 24; hour++) {
        result[hour] = {};
        for (const day of daysToShow) {
            result[hour][day] = [];
            
            for (let slot = 0; slot < 4; slot++) {
                const weekData = data[hour][day][slot];
                const weekIds = Object.keys(weekData);
                
                let avg = 0;
                if (weekIds.length > 0) {
                    let total = 0;
                    for (const weekId of weekIds) {
                        total += weekData[weekId].size;
                    }
                    avg = Math.round(total / weekIds.length * 10) / 10;
                }
                
                result[hour][day].push(avg);
                
                if (avg < globalMin) globalMin = avg;
                if (avg > globalMax) globalMax = avg;
            }
        }
    }
    
    return { 
        data: result, 
        min: globalMin === Infinity ? 0 : globalMin, 
        max: globalMax === -Infinity ? 0 : globalMax, 
        days: daysToShow,
        is15Min: true
    };
}

// ============================================
// USER AGGREGATION
// ============================================

/**
 * Aggregate user data - hourly view
 * Shows percentage of weeks the user was active at least once during that hour
 */
function aggregateUserDataHourly(factionData, userId, dayFilter) {
    const daysToShow = parseDaysFilter(dayFilter);
    const thirtyDaysAgo = getThirtyDaysAgo();
    const now = Math.floor(Date.now() / 1000);
    
    // Track which weeks have data for each (hour, day) and which the user was active
    // Structure: [hour][day] = { weeksWithData: Set, weeksActive: Set }
    const hourlyData = {};
    for (let hour = 0; hour < 24; hour++) {
        hourlyData[hour] = {};
        for (const day of daysToShow) {
            hourlyData[hour][day] = {
                weeksWithData: new Set(),
                weeksActive: new Set()
            };
        }
    }
    
    // Process snapshots
    for (const snapshot of factionData.snapshots) {
        if (snapshot.timestamp < thirtyDaysAgo) continue;
        
        const day = getDayOfWeek(snapshot.timestamp);
        if (!daysToShow.includes(day)) continue;
        
        const hour = getHourFromTimestamp(snapshot.timestamp);
        const weekId = getWeekId(snapshot.timestamp, now);
        
        // Mark that we have data for this week at this hour/day
        hourlyData[hour][day].weeksWithData.add(weekId);
        
        // Check if user was active
        if (snapshot.active.includes(userId)) {
            hourlyData[hour][day].weeksActive.add(weekId);
        }
    }
    
    // Calculate percentages
    const result = {};
    
    for (let hour = 0; hour < 24; hour++) {
        result[hour] = {};
        for (const day of daysToShow) {
            const { weeksWithData, weeksActive } = hourlyData[hour][day];
            
            if (weeksWithData.size === 0) {
                result[hour][day] = 0;
            } else {
                result[hour][day] = Math.round((weeksActive.size / weeksWithData.size) * 100);
            }
        }
    }
    
    return { 
        data: result, 
        min: 0, 
        max: 100, 
        days: daysToShow,
        isPercentage: true
    };
}

/**
 * Aggregate user data - 15min view (compact format)
 * Shows percentage of times the user was active in each 15-min slot
 */
function aggregateUserData15Min(factionData, userId, dayFilter) {
    const daysToShow = parseDaysFilter(dayFilter);
    const thirtyDaysAgo = getThirtyDaysAgo();
    
    // Structure: [hour][day][slot] = { total: 0, active: 0 }
    const data = {};
    for (let hour = 0; hour < 24; hour++) {
        data[hour] = {};
        for (const day of daysToShow) {
            data[hour][day] = {
                0: { total: 0, active: 0 },
                1: { total: 0, active: 0 },
                2: { total: 0, active: 0 },
                3: { total: 0, active: 0 }
            };
        }
    }
    
    // Process snapshots
    for (const snapshot of factionData.snapshots) {
        if (snapshot.timestamp < thirtyDaysAgo) continue;
        
        const day = getDayOfWeek(snapshot.timestamp);
        if (!daysToShow.includes(day)) continue;
        
        const hour = getHourFromTimestamp(snapshot.timestamp);
        const slot = get15MinSlotInHour(snapshot.timestamp);
        
        data[hour][day][slot].total++;
        
        if (snapshot.active.includes(userId)) {
            data[hour][day][slot].active++;
        }
    }
    
    // Calculate percentages
    const result = {};
    
    for (let hour = 0; hour < 24; hour++) {
        result[hour] = {};
        for (const day of daysToShow) {
            result[hour][day] = [];
            
            for (let slot = 0; slot < 4; slot++) {
                const { total, active } = data[hour][day][slot];
                
                if (total === 0) {
                    result[hour][day].push(0);
                } else {
                    result[hour][day].push(Math.round((active / total) * 100));
                }
            }
        }
    }
    
    return { 
        data: result, 
        min: 0, 
        max: 100, 
        days: daysToShow,
        is15Min: true,
        isPercentage: true
    };
}

// ============================================
// IMAGE GENERATION
// ============================================

/**
 * Generate heatmap image - standard hourly view
 */
function generateHeatmapImage(title, aggregatedData, subtitle = '') {
    const { data, min, max, days, isPercentage } = aggregatedData;
    
    const cellWidth = 55;
    const cellHeight = 28;
    const labelWidth = 60;
    const headerHeight = 50;
    const titleHeight = subtitle ? 65 : 45;
    const legendHeight = 40;
    const padding = 20;
    
    const width = labelWidth + (days.length * cellWidth) + padding * 2;
    const height = titleHeight + headerHeight + (24 * cellHeight) + legendHeight + padding * 2;
    
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#2C2F33';
    ctx.fillRect(0, 0, width, height);
    
    // Title
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(title, width / 2, padding + 25);
    
    // Subtitle
    if (subtitle) {
        ctx.font = '12px Arial';
        ctx.fillStyle = '#AAAAAA';
        ctx.fillText(subtitle, width / 2, padding + 45);
    }
    
    // Day headers
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    
    days.forEach((day, i) => {
        const x = padding + labelWidth + (i * cellWidth) + cellWidth / 2;
        const y = padding + titleHeight + 30;
        ctx.fillStyle = '#FFFFFF';
        ctx.fillText(DAY_LABELS[day], x, y);
    });
    
    // Time labels and cells
    ctx.font = '12px Arial';
    
    for (let hour = 0; hour < 24; hour++) {
        const y = padding + titleHeight + headerHeight + (hour * cellHeight);
        
        // Time label
        ctx.fillStyle = '#AAAAAA';
        ctx.textAlign = 'right';
        ctx.fillText(`${hour.toString().padStart(2, '0')}:00`, padding + labelWidth - 8, y + cellHeight / 2 + 4);
        
        // Cells
        days.forEach((day, i) => {
            const x = padding + labelWidth + (i * cellWidth);
            const value = data[hour][day];
            
            // Cell background
            ctx.fillStyle = getColor(value, min, max);
            ctx.fillRect(x + 2, y + 2, cellWidth - 4, cellHeight - 4);
            
            // Cell border
            ctx.strokeStyle = '#1E2124';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 2, y + 2, cellWidth - 4, cellHeight - 4);
            
            // Cell value
            ctx.fillStyle = getTextColor(value, min, max);
            ctx.textAlign = 'center';
            ctx.font = '12px Arial';
            
            let displayValue;
            if (isPercentage) {
                displayValue = `${Math.round(value)}%`;
            } else {
                displayValue = Number.isInteger(value) ? value.toString() : value.toFixed(1);
            }
            ctx.fillText(displayValue, x + cellWidth / 2, y + cellHeight / 2 + 4);
        });
    }
    
    // Legend
    const legendY = height - legendHeight - padding + 10;
    const legendWidth = 200;
    const legendX = (width - legendWidth) / 2;
    
    const gradient = ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
    gradient.addColorStop(0, 'rgb(255, 50, 50)');
    gradient.addColorStop(0.5, 'rgb(255, 255, 50)');
    gradient.addColorStop(1, 'rgb(50, 255, 50)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(legendX, legendY, legendWidth, 15);
    
    ctx.strokeStyle = '#1E2124';
    ctx.strokeRect(legendX, legendY, legendWidth, 15);
    
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '11px Arial';
    ctx.textAlign = 'center';
    
    const minLabel = isPercentage ? `${min}%` : min.toString();
    const maxLabel = isPercentage ? `${max}%` : max.toString();
    ctx.fillText(minLabel, legendX, legendY + 28);
    ctx.fillText(maxLabel, legendX + legendWidth, legendY + 28);
    
    return canvas.toBuffer('image/png');
}

/**
 * Generate compact 15-min heatmap
 * Each cell shows 4 values: "5|7|8|6"
 */
function generateCompact15MinImage(title, aggregatedData, subtitle = '') {
    const { data, min, max, days, isPercentage } = aggregatedData;
    
    const cellWidth = 75; // Wider to fit "XX|XX|XX|XX"
    const cellHeight = 24;
    const labelWidth = 60;
    const headerHeight = 50;
    const titleHeight = subtitle ? 65 : 45;
    const legendHeight = 50;
    const padding = 20;
    
    const width = labelWidth + (days.length * cellWidth) + padding * 2;
    const height = titleHeight + headerHeight + (24 * cellHeight) + legendHeight + padding * 2;
    
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#2C2F33';
    ctx.fillRect(0, 0, width, height);
    
    // Title
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(title, width / 2, padding + 25);
    
    // Subtitle
    if (subtitle) {
        ctx.font = '12px Arial';
        ctx.fillStyle = '#AAAAAA';
        ctx.fillText(subtitle, width / 2, padding + 45);
    }
    
    // Day headers
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    
    days.forEach((day, i) => {
        const x = padding + labelWidth + (i * cellWidth) + cellWidth / 2;
        const y = padding + titleHeight + 30;
        ctx.fillStyle = '#FFFFFF';
        ctx.fillText(DAY_LABELS[day], x, y);
    });
    
    // Time labels and cells
    for (let hour = 0; hour < 24; hour++) {
        const y = padding + titleHeight + headerHeight + (hour * cellHeight);
        
        // Time label
        ctx.fillStyle = '#AAAAAA';
        ctx.textAlign = 'right';
        ctx.font = '11px Arial';
        ctx.fillText(`${hour.toString().padStart(2, '0')}:00`, padding + labelWidth - 8, y + cellHeight / 2 + 4);
        
        // Cells with 4 sub-values
        days.forEach((day, i) => {
            const x = padding + labelWidth + (i * cellWidth);
            const values = data[hour][day]; // Array of 4 values
            
            // Calculate average for background color
            const avg = values.reduce((a, b) => a + b, 0) / 4;
            
            // Cell background
            ctx.fillStyle = getColor(avg, min, max);
            ctx.fillRect(x + 2, y + 2, cellWidth - 4, cellHeight - 4);
            
            // Cell border
            ctx.strokeStyle = '#1E2124';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 2, y + 2, cellWidth - 4, cellHeight - 4);
            
            // Draw 4 sub-values
            const subWidth = (cellWidth - 4) / 4;
            
            for (let slot = 0; slot < 4; slot++) {
                const subX = x + 2 + (slot * subWidth);
                const val = values[slot];
                
                // Sub-cell background
                ctx.fillStyle = getColor(val, min, max);
                ctx.fillRect(subX + 1, y + 3, subWidth - 2, cellHeight - 6);
                
                // Value text
                ctx.fillStyle = getTextColor(val, min, max);
                ctx.textAlign = 'center';
                ctx.font = '9px Arial';
                
                let displayVal;
                if (isPercentage) {
                    displayVal = Math.round(val).toString();
                } else {
                    displayVal = Math.round(val).toString();
                }
                ctx.fillText(displayVal, subX + subWidth / 2, y + cellHeight / 2 + 3);
            }
        });
    }
    
    // Legend
    const legendY = height - legendHeight - padding + 10;
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '11px Arial';
    ctx.textAlign = 'center';
    
    const legendText = isPercentage 
        ? 'Each cell: :00 | :15 | :30 | :45 (% active)'
        : 'Each cell: :00 | :15 | :30 | :45 (avg members)';
    ctx.fillText(legendText, width / 2, legendY);
    
    // Color gradient
    const gradWidth = 150;
    const gradX = (width - gradWidth) / 2;
    
    const gradient = ctx.createLinearGradient(gradX, 0, gradX + gradWidth, 0);
    gradient.addColorStop(0, 'rgb(255, 50, 50)');
    gradient.addColorStop(0.5, 'rgb(255, 255, 50)');
    gradient.addColorStop(1, 'rgb(50, 255, 50)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(gradX, legendY + 10, gradWidth, 12);
    
    ctx.strokeStyle = '#1E2124';
    ctx.strokeRect(gradX, legendY + 10, gradWidth, 12);
    
    const minLabel = isPercentage ? '0%' : min.toString();
    const maxLabel = isPercentage ? '100%' : max.toString();
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText(minLabel, gradX, legendY + 35);
    ctx.fillText(maxLabel, gradX + gradWidth, legendY + 35);
    
    return canvas.toBuffer('image/png');
}

/**
 * Generate comparison side-by-side image
 */
function generateComparisonImage(title1, data1, title2, data2) {
    const days = data1.days;
    const is15Min = data1.is15Min;
    
    const cellWidth = is15Min ? 65 : 45;
    const cellHeight = 22;
    const labelWidth = 45;
    const headerHeight = 45;
    const titleHeight = 35;
    const gapWidth = 25;
    const padding = 15;
    const sectionWidth = labelWidth + (days.length * cellWidth);
    
    const width = (sectionWidth * 2) + gapWidth + padding * 2;
    const height = titleHeight + headerHeight + (24 * cellHeight) + padding * 2 + 30;
    
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = '#2C2F33';
    ctx.fillRect(0, 0, width, height);
    
    const globalMin = Math.min(data1.min, data2.min);
    const globalMax = Math.max(data1.max, data2.max);
    
    function drawSection(data, title, offsetX) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 13px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(title, offsetX + sectionWidth / 2, padding + 20);
        
        ctx.font = 'bold 10px Arial';
        days.forEach((day, i) => {
            const x = offsetX + labelWidth + (i * cellWidth) + cellWidth / 2;
            ctx.fillText(DAY_LABELS[day], x, padding + titleHeight + 22);
        });
        
        for (let hour = 0; hour < 24; hour++) {
            const y = padding + titleHeight + headerHeight + (hour * cellHeight);
            
            if (offsetX === padding) {
                ctx.fillStyle = '#AAAAAA';
                ctx.textAlign = 'right';
                ctx.font = '9px Arial';
                ctx.fillText(`${hour.toString().padStart(2, '0')}:00`, offsetX + labelWidth - 4, y + cellHeight / 2 + 3);
            }
            
            days.forEach((day, i) => {
                const x = offsetX + labelWidth + (i * cellWidth);
                
                if (is15Min) {
                    // Draw 4 sub-cells
                    const values = data.data[hour][day];
                    const subWidth = (cellWidth - 2) / 4;
                    
                    for (let slot = 0; slot < 4; slot++) {
                        const subX = x + 1 + (slot * subWidth);
                        const val = values[slot];
                        
                        ctx.fillStyle = getColor(val, globalMin, globalMax);
                        ctx.fillRect(subX, y + 1, subWidth - 1, cellHeight - 2);
                        
                        ctx.fillStyle = getTextColor(val, globalMin, globalMax);
                        ctx.textAlign = 'center';
                        ctx.font = '7px Arial';
                        ctx.fillText(Math.round(val).toString(), subX + subWidth / 2, y + cellHeight / 2 + 2);
                    }
                } else {
                    const value = data.data[hour][day];
                    
                    ctx.fillStyle = getColor(value, globalMin, globalMax);
                    ctx.fillRect(x + 1, y + 1, cellWidth - 2, cellHeight - 2);
                    
                    ctx.strokeStyle = '#1E2124';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 1, y + 1, cellWidth - 2, cellHeight - 2);
                    
                    ctx.fillStyle = getTextColor(value, globalMin, globalMax);
                    ctx.textAlign = 'center';
                    ctx.font = '9px Arial';
                    const displayValue = Number.isInteger(value) ? value.toString() : value.toFixed(1);
                    ctx.fillText(displayValue, x + cellWidth / 2, y + cellHeight / 2 + 3);
                }
            });
        }
    }
    
    drawSection(data1, title1, padding);
    drawSection(data2, title2, padding + sectionWidth + gapWidth);
    
    return canvas.toBuffer('image/png');
}

/**
 * Generate difference heatmap
 */
function generateDifferenceImage(title1, data1, title2, data2) {
    const days = data1.days;
    const is15Min = data1.is15Min;
    
    const cellWidth = is15Min ? 75 : 55;
    const cellHeight = is15Min ? 24 : 28;
    const labelWidth = 60;
    const headerHeight = 50;
    const titleHeight = 45;
    const legendHeight = 50;
    const padding = 20;
    
    const width = labelWidth + (days.length * cellWidth) + padding * 2;
    const height = titleHeight + headerHeight + (24 * cellHeight) + legendHeight + padding * 2;
    
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = '#2C2F33';
    ctx.fillRect(0, 0, width, height);
    
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Difference: ${title1} vs ${title2}`, width / 2, padding + 25);
    
    ctx.font = 'bold 14px Arial';
    days.forEach((day, i) => {
        const x = padding + labelWidth + (i * cellWidth) + cellWidth / 2;
        ctx.fillText(DAY_LABELS[day], x, padding + titleHeight + 30);
    });
    
    // Calculate differences and find range
    let diffMin = Infinity;
    let diffMax = -Infinity;
    
    const diffData = {};
    for (let hour = 0; hour < 24; hour++) {
        diffData[hour] = {};
        for (const day of days) {
            if (is15Min) {
                diffData[hour][day] = [];
                for (let slot = 0; slot < 4; slot++) {
                    const diff = data1.data[hour][day][slot] - data2.data[hour][day][slot];
                    diffData[hour][day].push(diff);
                    if (diff < diffMin) diffMin = diff;
                    if (diff > diffMax) diffMax = diff;
                }
            } else {
                const diff = data1.data[hour][day] - data2.data[hour][day];
                diffData[hour][day] = diff;
                if (diff < diffMin) diffMin = diff;
                if (diff > diffMax) diffMax = diff;
            }
        }
    }
    
    function getDiffColor(value) {
        const absMax = Math.max(Math.abs(diffMin), Math.abs(diffMax), 1);
        const ratio = value / absMax;
        
        if (ratio < 0) {
            const t = Math.min(1, Math.abs(ratio));
            return `rgb(255, ${Math.round(255 * (1 - t))}, ${Math.round(255 * (1 - t))})`;
        } else {
            const t = Math.min(1, ratio);
            return `rgb(${Math.round(255 * (1 - t))}, 255, ${Math.round(255 * (1 - t))})`;
        }
    }
    
    for (let hour = 0; hour < 24; hour++) {
        const y = padding + titleHeight + headerHeight + (hour * cellHeight);
        
        ctx.fillStyle = '#AAAAAA';
        ctx.textAlign = 'right';
        ctx.font = '11px Arial';
        ctx.fillText(`${hour.toString().padStart(2, '0')}:00`, padding + labelWidth - 8, y + cellHeight / 2 + 4);
        
        days.forEach((day, i) => {
            const x = padding + labelWidth + (i * cellWidth);
            
            if (is15Min) {
                const values = diffData[hour][day];
                const subWidth = (cellWidth - 4) / 4;
                
                for (let slot = 0; slot < 4; slot++) {
                    const subX = x + 2 + (slot * subWidth);
                    const val = values[slot];
                    
                    ctx.fillStyle = getDiffColor(val);
                    ctx.fillRect(subX + 1, y + 3, subWidth - 2, cellHeight - 6);
                    
                    ctx.fillStyle = '#000000';
                    ctx.textAlign = 'center';
                    ctx.font = '8px Arial';
                    const sign = val > 0 ? '+' : '';
                    ctx.fillText(`${sign}${Math.round(val)}`, subX + subWidth / 2, y + cellHeight / 2 + 3);
                }
            } else {
                const value = diffData[hour][day];
                
                ctx.fillStyle = getDiffColor(value);
                ctx.fillRect(x + 2, y + 2, cellWidth - 4, cellHeight - 4);
                
                ctx.strokeStyle = '#1E2124';
                ctx.strokeRect(x + 2, y + 2, cellWidth - 4, cellHeight - 4);
                
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'center';
                ctx.font = '11px Arial';
                const sign = value > 0 ? '+' : '';
                ctx.fillText(`${sign}${value.toFixed(1)}`, x + cellWidth / 2, y + cellHeight / 2 + 4);
            }
        });
    }
    
    const legendY = height - legendHeight - padding + 15;
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Green = ${title1} higher | Red = ${title2} higher`, width / 2, legendY + 15);
    
    return canvas.toBuffer('image/png');
}

// ============================================
// PUBLIC API
// ============================================

async function createFactionHeatmap(factionId, granularity, dayFilter) {
    const factionData = storage.loadFactionData(factionId);
    
    if (!factionData.snapshots || factionData.snapshots.length === 0) {
        throw new Error(`No data available for faction ${factionId}. Wait for data collection.`);
    }
    
    const title = `${factionData.name || 'Faction'} [${factionId}]`;
    const numWeeks = getUniqueWeeks(factionData.snapshots, Math.floor(Date.now() / 1000));
    const subtitle = `Last 30 days (${numWeeks} week${numWeeks !== 1 ? 's' : ''} of data) - Avg unique active per hour`;
    
    if (granularity === '15min') {
        const aggregated = aggregateFactionData15Min(factionData, dayFilter);
        return generateCompact15MinImage(title, aggregated, subtitle);
    } else {
        const aggregated = aggregateFactionDataHourly(factionData, dayFilter);
        return generateHeatmapImage(title, aggregated, subtitle);
    }
}

async function createUserHeatmap(userId, granularity, dayFilter) {
    const factionId = storage.findUserFaction(userId);
    
    if (!factionId) {
        throw new Error(`User ${userId} not found in any tracked faction.`);
    }
    
    const factionData = storage.loadFactionData(factionId);
    const numWeeks = getUniqueWeeks(factionData.snapshots, Math.floor(Date.now() / 1000));
    
    const title = `User ${userId}`;
    const subtitle = `Last 30 days (${numWeeks} week${numWeeks !== 1 ? 's' : ''}) - % of time active`;
    
    if (granularity === '15min') {
        const aggregated = aggregateUserData15Min(factionData, userId, dayFilter);
        return generateCompact15MinImage(title, aggregated, subtitle);
    } else {
        const aggregated = aggregateUserDataHourly(factionData, userId, dayFilter);
        return generateHeatmapImage(title, aggregated, subtitle);
    }
}

async function createComparisonHeatmaps(faction1Id, faction2Id, granularity, dayFilter) {
    const faction1Data = storage.loadFactionData(faction1Id);
    const faction2Data = storage.loadFactionData(faction2Id);
    
    if (!faction1Data.snapshots?.length) {
        throw new Error(`No data available for faction ${faction1Id}.`);
    }
    
    if (!faction2Data.snapshots?.length) {
        throw new Error(`No data available for faction ${faction2Id}.`);
    }
    
    const name1 = faction1Data.name || `Faction ${faction1Id}`;
    const name2 = faction2Data.name || `Faction ${faction2Id}`;
    
    let agg1, agg2;
    
    if (granularity === '15min') {
        agg1 = aggregateFactionData15Min(faction1Data, dayFilter);
        agg2 = aggregateFactionData15Min(faction2Data, dayFilter);
    } else {
        agg1 = aggregateFactionDataHourly(faction1Data, dayFilter);
        agg2 = aggregateFactionDataHourly(faction2Data, dayFilter);
    }
    
    const sideBySide = generateComparisonImage(name1, agg1, name2, agg2);
    const difference = generateDifferenceImage(name1, agg1, name2, agg2);
    
    return { sideBySide, difference };
}

module.exports = {
    createFactionHeatmap,
    createUserHeatmap,
    createComparisonHeatmaps
};

================================================================================

File: src/index.js
----------------------------------------
require('dotenv').config();

const { Client, GatewayIntentBits, Collection, REST, Routes } = require('discord.js');
const collector = require('./collector');

const activityCommand = require('./commands/activity');
const configCommand = require('./commands/config');

const client = new Client({ 
    intents: [GatewayIntentBits.Guilds] 
});

client.commands = new Collection();
client.commands.set(activityCommand.data.name, activityCommand);
client.commands.set(configCommand.data.name, configCommand);

async function registerCommands() {
    const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);
    
    const commands = [
        activityCommand.data.toJSON(),
        configCommand.data.toJSON()
    ];
    
    try {
        console.log('Registering slash commands...');
        
        await rest.put(
            Routes.applicationCommands(process.env.DISCORD_CLIENT_ID),
            { body: commands }
        );
        
        console.log('Slash commands registered successfully.');
    } catch (error) {
        console.error('Error registering commands:', error);
    }
}

client.once('ready', async () => {
    console.log(`Logged in as ${client.user.tag}`);
    
    await registerCommands();
    
    // Start the data collector
    collector.startCollector();
});

client.on('interactionCreate', async interaction => {
    if (!interaction.isChatInputCommand()) return;
    
    const command = client.commands.get(interaction.commandName);
    
    if (!command) return;
    
    try {
        await command.execute(interaction);
    } catch (error) {
        console.error('Command execution error:', error);
        
        const errorMessage = { 
            content: 'âŒ An error occurred while executing this command.', 
            ephemeral: true 
        };
        
        if (interaction.replied || interaction.deferred) {
            await interaction.followUp(errorMessage);
        } else {
            await interaction.reply(errorMessage);
        }
    }
});

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('Shutting down...');
    collector.stopCollector();
    client.destroy();
    process.exit(0);
});

// Login
client.login(process.env.DISCORD_TOKEN);

================================================================================

File: src/utils/api.js
----------------------------------------
const storage = require('./storage');

const API_BASE = 'https://api.torn.com';

async function fetchFaction(factionId) {
    const apiKey = storage.getNextApiKey();
    
    if (!apiKey) {
        throw new Error('No API keys configured. Use /config add apikeys to add one.');
    }
    
    const url = `${API_BASE}/faction/${factionId}?key=${apiKey}`;
    
    const response = await fetch(url);
    
    if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.error) {
        throw new Error(`Torn API error: ${data.error.error}`);
    }
    
    return data;
}

function processActivitySnapshot(factionData, pollTimestamp) {
    const activeMembers = [];
    const members = factionData.members || {};
    
    for (const [memberId, memberData] of Object.entries(members)) {
        const lastAction = memberData.last_action?.timestamp || 0;
        const timeDiff = pollTimestamp - lastAction;
        
        // Active if last action within 15 minutes (900 seconds)
        if (timeDiff <= 900) {
            activeMembers.push(parseInt(memberId));
        }
    }
    
    return {
        active: activeMembers,
        total: Object.keys(members).length
    };
}

module.exports = {
    fetchFaction,
    processActivitySnapshot
};

================================================================================

File: src/utils/helpers.js
----------------------------------------
const DAY_NAMES = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
const DAY_LABELS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

function parseDaysFilter(daysInput) {
    if (!daysInput || daysInput === 'all') {
        return [0, 1, 2, 3, 4, 5, 6];
    }
    
    if (daysInput === 'weekday') {
        return [1, 2, 3, 4, 5];
    }
    
    if (daysInput === 'weekend') {
        return [0, 6];
    }
    
    const days = daysInput.toLowerCase().split(',').map(d => d.trim());
    const indices = [];
    
    for (const day of days) {
        const index = DAY_NAMES.indexOf(day);
        if (index !== -1 && !indices.includes(index)) {
            indices.push(index);
        }
    }
    
    return indices.length > 0 ? indices.sort((a, b) => a - b) : [0, 1, 2, 3, 4, 5, 6];
}

function getTimeSlotIndex(timestamp, granularity) {
    const date = new Date(timestamp * 1000);
    const hours = date.getUTCHours();
    const minutes = date.getUTCMinutes();
    
    if (granularity === '15min') {
        return hours * 4 + Math.floor(minutes / 15);
    }
    
    return hours;
}

function getHourFromTimestamp(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.getUTCHours();
}

function get15MinSlotInHour(timestamp) {
    const date = new Date(timestamp * 1000);
    return Math.floor(date.getUTCMinutes() / 15);
}

function getDayOfWeek(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.getUTCDay();
}

function formatTimeSlot(index, granularity) {
    if (granularity === '15min') {
        const hours = Math.floor(index / 4);
        const minutes = (index % 4) * 15;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    }
    
    return `${index.toString().padStart(2, '0')}:00`;
}

function getSlotCount(granularity) {
    return granularity === '15min' ? 96 : 24;
}

function getThirtyDaysAgo() {
    return Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60);
}

// Get week identifier (0 = current week, 1 = last week, etc.)
function getWeekId(timestamp, referenceTimestamp) {
    const refDate = new Date(referenceTimestamp * 1000);
    const targetDate = new Date(timestamp * 1000);
    
    // Get start of week (Sunday) for reference
    const refWeekStart = new Date(refDate);
    refWeekStart.setUTCHours(0, 0, 0, 0);
    refWeekStart.setUTCDate(refWeekStart.getUTCDate() - refWeekStart.getUTCDay());
    
    // Get start of week for target
    const targetWeekStart = new Date(targetDate);
    targetWeekStart.setUTCHours(0, 0, 0, 0);
    targetWeekStart.setUTCDate(targetWeekStart.getUTCDate() - targetWeekStart.getUTCDay());
    
    const diffMs = refWeekStart.getTime() - targetWeekStart.getTime();
    const diffWeeks = Math.floor(diffMs / (7 * 24 * 60 * 60 * 1000));
    
    return diffWeeks;
}

// Get unique week IDs from snapshots
function getUniqueWeeks(snapshots, referenceTimestamp) {
    const weeks = new Set();
    for (const snapshot of snapshots) {
        weeks.add(getWeekId(snapshot.timestamp, referenceTimestamp));
    }
    return weeks.size;
}

module.exports = {
    DAY_NAMES,
    DAY_LABELS,
    parseDaysFilter,
    getTimeSlotIndex,
    getHourFromTimestamp,
    get15MinSlotInHour,
    getDayOfWeek,
    formatTimeSlot,
    getSlotCount,
    getThirtyDaysAgo,
    getWeekId,
    getUniqueWeeks
};

================================================================================

File: src/utils/storage.js
----------------------------------------
const fs = require('fs');
const path = require('path');

const CONFIG_PATH = path.join(__dirname, '../../config.json');
const DATA_DIR = path.join(__dirname, '../../data');

function ensureDataDir() {
    if (!fs.existsSync(DATA_DIR)) {
        fs.mkdirSync(DATA_DIR, { recursive: true });
    }
}

function loadConfig() {
    try {
        const data = fs.readFileSync(CONFIG_PATH, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        return { factions: [], apikeys: [], currentKeyIndex: 0 };
    }
}

function saveConfig(config) {
    fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2));
}

function getFactionDataPath(factionId) {
    return path.join(DATA_DIR, `faction_${factionId}.json`);
}

function loadFactionData(factionId) {
    ensureDataDir();
    const filePath = getFactionDataPath(factionId);
    
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        return {
            factionId: factionId,
            name: null,
            snapshots: []
        };
    }
}

function saveFactionData(factionId, data) {
    ensureDataDir();
    const filePath = getFactionDataPath(factionId);
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
}

function addSnapshot(factionId, factionName, timestamp, activeMembers, totalMembers) {
    const data = loadFactionData(factionId);
    data.name = factionName;
    
    data.snapshots.push({
        timestamp,
        active: activeMembers,
        total: totalMembers
    });
    
    // Prune old data (older than 30 days)
    const thirtyDaysAgo = Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60);
    data.snapshots = data.snapshots.filter(s => s.timestamp >= thirtyDaysAgo);
    
    saveFactionData(factionId, data);
}

function getNextApiKey() {
    const config = loadConfig();
    
    if (config.apikeys.length === 0) {
        return null;
    }
    
    const key = config.apikeys[config.currentKeyIndex];
    config.currentKeyIndex = (config.currentKeyIndex + 1) % config.apikeys.length;
    saveConfig(config);
    
    return key;
}

function findUserFaction(userId) {
    ensureDataDir();
    const files = fs.readdirSync(DATA_DIR).filter(f => f.startsWith('faction_') && f.endsWith('.json'));
    
    for (const file of files) {
        const filePath = path.join(DATA_DIR, file);
        try {
            const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            
            for (const snapshot of data.snapshots) {
                if (snapshot.active.includes(userId)) {
                    return data.factionId;
                }
            }
        } catch (error) {
            continue;
        }
    }
    
    return null;
}

function getAllFactionData() {
    ensureDataDir();
    const files = fs.readdirSync(DATA_DIR).filter(f => f.startsWith('faction_') && f.endsWith('.json'));
    const factions = {};
    
    for (const file of files) {
        const filePath = path.join(DATA_DIR, file);
        try {
            const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            factions[data.factionId] = data;
        } catch (error) {
            continue;
        }
    }
    
    return factions;
}

module.exports = {
    loadConfig,
    saveConfig,
    loadFactionData,
    saveFactionData,
    addSnapshot,
    getNextApiKey,
    findUserFaction,
    getAllFactionData
};

================================================================================

File: config.json
----------------------------------------
{
  "factions": [
    47878,
    8677
  ],
  "apikeys": [
    "r8ixcUfQoiLgx7Uo"
  ],
  "currentKeyIndex": 0
}

================================================================================
